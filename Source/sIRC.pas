{  sIRC.pas  Copyright (c) 2019 Paul Davidson. All rights reserved.}unit sIRC;  {$MODE OBJFPC}  {$H+}interface  uses    cthreads,    cmem,     BlckSock,    Classes;  type        tIRC = class( TThread )      private         fBall8     : TStringList;         fAPIXU     : string;         fChannel   : string;         fCritical  : TRTLCriticalSection;                      // Main thread may write at same time         fNetwork   : string;         fOEDAppID  : string;         fOEDKey    : string;         fPassword  : string;         fPending   : string;                                   // Message waiting for fLog.send         fPort      : string;         fSock      : TTCPBlockSocket;         fStarted   : boolean;         fTimeout   : integer;         fVersion   : string;         fUserName  : string;         function  HTTPGet( addr, hdrs : string ) : string;         function  JSONDefine( const s : string ) : string;         function  JSONSynonyms( s : string ) : string;         function  JSONWiki( s : string ) : string;         procedure LoginID;         procedure Nicks( s : string );         function  Shao( nick, para, s : string ) : string;         function  SpaceX : string;      protected         procedure Execute; override;      public        constructor Create;        destructor  Destroy; override;        property    Channel : string write fChannel;        procedure   MsgChat( s : string );        procedure   MsgSend( s : string );        property    APIXU : string write fAPIXU;        property    Network : string write fNetwork;        property    OEDAppID : string write fOEDAppID;        property    OEDKey : string write fOEDKey;        property    Password : string write fPassword;        property    Port : string write fPort;        property    Started : boolean read fStarted;        property    Version : string write fVersion;        property    UserName : string write fUserName;    end;  // tIRC{   tIRCChan = class( TStringList )     private       fChannel  : string;       fCountMax : integer;     public       constructor Create;       constructor Destroy; override;       property    ChannelGet : string read fChannel;       function    Connect( s : string ) : string;       property    CountMax : integer write fCountMax;       function    Disconnect : string;       procedure   Display;   end;  // tIRCChan}var  fIRC : tIRC;implementation  uses    DateUtils,    fpJSON,    fphttpclient,    JSONParser,    OpenSSL,    sConsole,    sNote,    sProfile,    sWeather,    httpsend,    ssl_openssl,    ssl_openssl_lib,    synacode,    StrUtils,    SysUtils;  const    CRLF     : string = #13 + #10;      constructor tIRC.Create;    // create IRC thread  begin    inherited Create( TRUE );    fBall8   := TStringList.Create;    fNote    := tNote.Create;    fPending := '';     fStarted := FALSE;    fTimeout := 1;    InitCriticalSection( fCritical );  end;  //  tIRC.Create       destructor tIRC.Destroy;    // Shoot down thread and frieds  begin    try      fBall8.Free;      fSock.CloseSocket;      fSock.Free;    except    end;    DoneCriticalSection( fCritical );    inherited Destroy;  end;  // tIRC.Destroy  procedure tIRC.Execute;    // Main loop  var    Comm  : string;       // Command in server response    Nick  : string;       // Nick in server response    Ops   : TStringList;  // Ops list    Para  : string;       // Parameter part of response    sHost : string;    sTime : TDateTime;    tTime : TDateTime;    i     : integer;    s     : string;    t     : string;  begin    randomize;    Ops   := TStringList.Create;    sTime := Now;    fSock := TTCPBlockSocket.Create;    fSock.Connect( fNetwork, fPort );    if fSock.LastError = 0      then fCon.Send( 'Connected to ' + fNetwork + ' port ' + fPort, taNormal )      else fCon.Send( 'Connect error ' + fSock.LastErrorDesc, taNormal );    fCon.Send( 'Waiting', taNormal );    sleep( 2000 );    LoginID;    while ( fSock.LastError = 0 ) and not Terminated do begin       // Chat loop       if fSock.WaitingData > 0 then begin                           // Is there stuff waiting        s := trim( fSock.RecvString( fTimeOut ) );                  // Read it        s := ReplaceStr( s, #01, '~' );                             // Change CTCP marks        if ( s <> '' ) and ( s[ 1 ] = ':' ) then begin          s    := copy( s, 2, length( s ) );                        // Remove leading :          Nick := trim( copy( s, 1, pos( '!', s ) - 1 ) );          // Extract Nick          s    := copy( s, pos( ' ', s ) + 1, length( s ) );        // Remove rest of address          Comm := uppercase( copy( s, 1, pos( ' ', s ) - 1 ) );     // Extract command          Para := copy( s, pos( ' ', s ) + 1, length( s ) );        // Extract parameter        end else begin          Nick := '';          Comm := trim( copy( s, 1, pos( ' ', s + ' ' ) ) );          Para := trim( copy( s, pos( ' ', s + ' ') + 1, length( s ) ) );        end;        case Comm of  // process message          '001'     : s := 'Logged in as ' + fUserName;                                     // 001 RPL_WELCOME          '002'     : begin                                                                 // 002 RPL_YOURHOST                        sHost := copy( s, pos( ':', s ) + 14,  length( s ) );                        s     := 'Host: ' + sHost;                      end;          '003'     : s := '';                                                              // 003 RPL_CREATED          '004'     : s := '';                                                              // 004 RPL_MYINFO          '005'     : s := '';                                                              // 005 RPL_ISUPPORT          '250'     : s := '';                                                              // 250           '251'     : s := '';                                                              // 251 RPL_LUSERCLIENT          '252'     : s := '';                                                              // 252 RPL_LUSEROP          '253'     : s := '';                                                              // 253 RPL_LUSERUNKNOWN          '254'     : s := '';                                                              // 254 RPL_LUSERCHANNELS          '255'     : s := '';                                                              // 255 RPL_LUSERME          '265'     : s := '';                                                              // 265 RPL_LOCALUSERS          '266'     : s := '';                                                              // 266 RPL_GLOBALUSERS          '332'     : s := copy( s, pos( ':', s ) + 1, length( s ) );                       // 332 RPL_TOPIC          '333'     : s := '';                                                              // 333 RPL_TOPICWHOTIME          '351'     : s := '';                                                              // 351 RPL_VERSION          '353'     : begin                                                                 // 353 RPL_NAMREPLY                        s := copy( Para, pos( ':', Para ) + 1, length( Para ) );                        Nicks( s );                        s := 'Nicks: ' + s;                      end;          '366'     : s := '';                                                              // 366 RPL_ENDOFNAMES          '372'     : s := trim( copy( Para, pos( ':', Para ) + 2, length( Para ) ) );      // 372 RPL_MOTD          '373'     : s := Para;                                                            // 373 RPL_INFOSTART          '375'     : s := '';                                                              // 375 RPL_MOTDSTART          '376'     : s := '';                                                              // 376 RPL_ENDOFMOTD          '401'     : begin                                                                 // 401 ERR_NOSUCHNICK                        s := Nick + ' No such nick/channel';                        MsgChat( s );                      end;          '433'     : begin                                                                 // ERR_NICKNAMEINUSE                        fUserName := fUsername + '_';                        LoginID;                      end;          '486'     : s := '';                                                              // 486           'ERROR'   : begin                        s := 'Socket error; closing ' + Para;                        Self.Terminate;                      end;          'JOIN'    : begin                        fCon.Send( Nick + ' joined ' + fChannel, taNormal );                        if uppercase( Nick ) = uppercase( fUserName ) then begin                          fStarted := TRUE;                          MsgChat( 'Morning' );                          fCon.Send( fUsername + '> Morning', taBold );                        end;                        while fNote.Check( Nick ) do begin                          s := fNote.Fetch( Nick );                          if length( trim( s ) ) > 0 then MsgChat( Nick + ' ' + s );                        end;                        s := '';                      end;          'MODE'    : begin                        s := 'Mode set to ' + copy( Para, pos( ':', Para ) + 1, length( Para ) ) ;                        MsgSend( 'JOIN ' + fChannel );                        fCon.Send( fUserName + '> JOIN ' + fChannel, taBold );                      end;          'NOTICE'  : begin                        s := '';                        if pos( '~TIME ', uppercase( Para ) ) > 0 then begin                          s := Nick + ': ' + copy( Para, pos( ':', Para ) + 2, length( Para ) );       //  <-  here 1 to 2                          if pos( '~TIME ', uppercase( Para ) ) > 0 then MsgChat( s );                        end else s := copy( Para, pos( ':', Para ) + 1, length( Para ) );                      end;          'PART'    : s := Nick + ' parted ' + fChannel;          'PING'    : begin                         fCon.Send( s, taNormal );                         fCon.Send( fUserName + ': PONG', taBold );                         MsgSend( 'PONG' );                         s := '';                      end;          'PRIVMSG' : begin                        Comm := copy( Para, pos( ':' , Para ) + 1, length( Para ) );                        Para := trim( copy( Comm, pos( ' ', Comm + ' ' ) + 1, length( Comm ) ) );                        s    := copy( s, pos( ':', s ) + 1, length( s ) );                        if pos( ' ', Comm ) <> 0 then Comm := copy( Comm, 1, pos( ' ', Comm ) - 1 );                        Comm := ReplaceStr( Comm, #01, '' );                                       // Remove CTCP marks                        Comm := uppercase( Comm );                        case Comm of                          '.8BALL'    : begin                                          fCon.Send( nick + '> ' + s , taNormal );                                          s := Shao( nick, para, s );                                          MsgChat( s );                                          s := fUserName + '> ' + s;                                        end;                          '.DEFINE'   : if length( Para ) > 0 then begin                                          fCon.Send( Nick + '> .Define ' + Para, taNormal );                                          s := 'APP_ID: ' + fOEDAppID + CRLF + 'APP_KEY: ' + fOEDKey + CRLF;                                          s := HTTPGet( 'https://od-api.oxforddictionaries.com:443/api/v1/entries/en/' + Lowercase( EncodeURL( Para ) ), s );                                          if copy( s, 1, 3 ) <> 'GET' then s := JSONDefine( s );                                          s := 'Define ' + uppercase( Para ) + ': ' + s;                                          MsgChat( s );                                           fCon.Send( fUserName + '> ' + s, taBold );                                          s := '';                                        end else begin                                          s := 'Define usage - .Define <word>';                                          MsgChat( s );                                          s := Nick  + '> ' + s;                                        end;                          '.DOF'      : begin                                          MsgChat( 'https://www.pointsinfocus.com/tools/depth-of-field-and-equivalent-lens-calculator' );                                          MsgChat( 'https://dofsimulator.net/en/' );                                          s := fUserName + '> Sent DoF URLs';                                        end;                          '.HELP'     : begin                                          fCon.Send( s, taNormal );                                          s := 'Help https://github.com/coraxyn/ShaoB/wiki/Commands';                                          MsgChat( s );                                          fPending := fUsername + '> ' + s;                                          s := Nick + '> .HELP';                                        end;                          '.HOST'     : begin                                          s := Nick + '> .Host';                                          MsgChat( 'Host: ' + sHost );                                          fPending := fUserName + '> Host: ' + sHost;                                        end;                          '.NOTE'     : begin                                          fCon.Send( nick + '> ' + s, taNormal );                                          if length( trim( para ) ) > 0                                             then s := fNote.Note( Nick, para )                                            else s := 'Usage: .Note <nick> <message>';                                          MsgChat( s );                                          fCon.Send( fUserName + '> ' + s, taBold );                                          s := '';                                        end;                          '.OPS'      : begin                                          fCon.Send( nick + '> ' + s, taNormal );                                          try                                            Ops.LoadFromFile( 'shao.ops' );                                            s := '';                                            for i := 1 to Ops.Count do begin                                              if length( s ) > 0 then s := s + ', ';                                               s := s + Ops.Strings[ i - 1 ];                                            end;                                            s := 'OPS: ' + s;                                          except                                            s := 'Ops list not available';                                          end;                                          MsgChat( s );                                          s := fUsername + '> ' + s;                                        end;                          '.PROFILE'  : begin                                          fCon.Send( nick + '> ' + s, taNormal );                                          s := Nick + '> ' + fProf.Parse( Nick, Para );                                          MsgChat( s );                                          s := Nick + '> ' + s;                                        end;                          '.QUIT'     : begin                                          fCon.Send( nick + '> ' + s, taNormal );                                          s := 'Quit yourself, ' + Nick;                                          MsgChat( s );                                          fCon.Send( fUserName + '> ' + s, taBold );                                          s := '';                                        end;                          '.SHAO'     : begin                                          fCon.Send( nick + '> ' + s, taNormal );                                          s := Shao( nick, para, s );                                          MsgChat( s );                                          s := fUserName + '> ' + s;                                        end;                          '.SPACEX'   : begin                                          fCon.Send( nick + '> ' + s, taNormal );                                          s := 'SpaceX: ' + SpaceX;                                          MsgChat( s );                                          s := fUserName + '> ' + s;                                        end;                          '.SYNONYMS' : if length( Para ) > 0 then begin                                          fCon.Send( Nick + '> .Synonyms ' + Para, taNormal );                                          s := 'APP_ID: ' + fOEDAppID + CRLF + 'APP_KEY: ' + fOEDKey + CRLF;                                          s := HTTPGet( 'https://od-api.oxforddictionaries.com:443/api/v1/entries/en/' + Lowercase( EncodeURL( Para ) ) + '/synonyms', s );                                          if pos( '404 Not Found', s ) > 0                                            then s := 'not found'                                            else if copy( s, 1, 3 ) <> 'GET'                                                    then s := JSONSynonyms( s );                                          s := 'Synonyms ' + uppercase( Para ) + ': ' + s;                                          MsgChat( s );                                           fCon.Send( fUserName + '> ' + s, taBold );                                          s := '';                                        end else begin                                          s := 'Synonyms usage - .Synonyms <word>';                                          MsgChat( s );                                          s := Nick  + '> ' + s;                                        end;                          '.TIME'     : begin                                          if length( Para ) > 0 then begin                                            if uppercase( Para ) = fUsername then begin                                              DateTimeToString( s, 'ddd mmm dd ', Date );                                              DateTimeToString( t, 'hh:mm:ss:zzz', Time );                                              s := s + t;                                            end else s := 'PRIVMSG ' + Para + ' :' + #01 + 'time' + #01;                                            MsgSend( s );                                            fPending := fUserName + '> ' + s;                                          end else MsgChat( 'Usage .Time nick' );                                          s := Nick + '> .Time ' + Para;                                        end;                          '.UP'       : begin                                         fCon.Send( nick + '> .up', taNormal );                                          tTime := Now;                                          s := 'Up time: ' + IntToStr( DaysBetween( tTime, sTime ) ) + ' days ' +                                                FormatDateTime('h" hrs, "n" min, "s" sec"', tTime - sTime );                                          MsgChat( s );                                          fCon.Send( fUsername + '> ' + s, taBold );                                          s := '';                                        end;                          '.VERSION'  : begin                                          fCon.Send( nick + '> ' + s, taNormal );                                          MsgChat( 'Version ' + fVersion );                                          fCon.Send( fUserName + '> Version ' + fVersion, taBold );                                          s := '';                                        end;                          '.WEATHER'  : begin                                          fCon.Send( nick + '> .weather ' + para, taNormal );                                          if uppercase( fChannel ) <> '#PHOTOGEEKS' then begin                                            s := fWeather.Command( nick, para );                                            MsgChat( s );                                            fCon.Send( fUsername + '> ' + s, taBold );                                            s := '';                                          end else s := fUsername + '> hidden weather';                                        end;                          '.WIKI'     : begin                                          fCon.Send( nick + '> ' + s, taNormal );                                          if length( Para ) > 0 then begin                                            s := HTTPGet( 'https://en.wikipedia.org/w/api.php?format=json&action=query&prop=extracts&exintro&explaintext&redirects=1&titles=' + EncodeURL( Para ), '' );                                            if copy( s, 1, 3 ) <> 'GET' then s := JSONWIKI( s );                                            if trim( s ) = '' then s := 'Multiple entries.  Please be more specific.';                                            s := 'Wiki ' + uppercase( Para ) + ': ' + s;                                            MsgChat( s );                                            fCon.Send(  fUserName + '> ' + s, taBold );                                            s := '';                                          end else begin                                            s := 'Wiki usage - .Wiki <word | phrase>';                                            MsgChat( s );                                            s := Nick  + '> ' + s;                                          end;                                        end;                          '~ACTION'   : begin                                          s := copy( s, pos( ' ', s ) + 1, length( s ) );                                          s := Nick + '> ' + s;                                        end;                          '~TIME'     : begin                                          DateTimeToString( s, 'ddd mmm dd ', Date );                                          DateTimeToString( t, 'hh:mm:ss:zzz', Time );                                          s := s + t;                                          MsgChat( s );                                          fCon.Send( fUsername + '> ' + s, taBold );                                        end;                          '~VERSION'  : begin                                          fCon.Send( 'VERSION', taNormal );                                          s := 'VERSION '+ fUserName + ' v.' + fVersion;                                          MsgSend( s );                                          fCon.Send( fUsername + '> ' + s, taBold );                                          s := '';                                        end;                          else s := Nick + '>  ' + s;                        end;  // PRIVMSG case                      end;  // PRIVMSG          else s := Nick + '> ' + s;       end;  // Case process messages       if length( s ) > 0 then fCon.Send( s, taNormal );                 // Write out normal message to console       if length( fPending ) > 0 then fCon.Send( fPending, taNormal );   // Write out any pending message       if pos( '> ', s ) > 0 then begin                                  // Write out .Note message for           t := leftStr( s, pos( '> ', s ) - 1 );          t := fNote.Fetch( t );                                         if length( t ) > 0 then begin           fCon.Send( fUserName + '> ' + Nick + ' ' + t, taBold );           MsgChat( Nick + ' ' + t );         end;       end;       s := '';       fPending := '';      end;  // if fSock.DataWaiting      if fSock.LastError <> 0 then begin        fCon.Send( fSock.GetErrorDescEx, taBold );        if fSock.LastError <> 9997          then fCon.Send( fSock.GetErrorDescEx, taBold )          else fSock.ResetLastError;      end;      sleep( 10 );    end;  // while    MsgSend( 'QUIT Laters :)' );    fNote.Free;    Ops.Free;    fCon.Send( 'IRC link ended', taNormal );    fCon.Terminate;  end;  // tIRC.Execute      function  tIRC.HTTPGet( addr, hdrs : string ) : string;    // get response string from page at addr    // hdrs is string of extra headers delimited with CRLF (INCLUDING LAST ONE!!!)  var    HTTP : THTTPSend;    i    : integer;    s    : string;    str  : TStringList;  begin    HTTP := THTTPSend.Create;    str  := TStringList.Create;    s     := '';    HTTP.Clear;    HTTP.KeepAlive := FALSE;    HTTP.sock.ResetLastError;    HTTP.TargetPort := '443';    HTTP.Protocol := '1.1';    while length( hdrs ) > 0 do begin      HTTP.Headers.Add( copy( hdrs, 1, pos( CRLF, hdrs ) ) );      hdrs := copy( hdrs, pos( CRLF, hdrs ) + 2, length( HDRS ) );    end; 	try	  if http.HTTPMethod( 'GET', addr ) then begin	    str.LoadFromStream( http.Document );	    for i := 0 to str.Count - 1 do	      s := s + str[ i ];	  end else s := 'GET error: ' + http.sock.GetErrorDescEx;	finally	  http.Free;	  str.Free;	end;	Result := s;  end;  // tIRC.Get  function tIRC.JSONDefine( const s : string ) : string;  var    jDat : TJSONData;    t   : string;  begin    try      jDat := GetJSON( s );      t    := jDat.AsJSON;        t    := copy( t, pos( 'definitions" : [', t ) + 17, length( t ) );       t    := copy( t, 1, pos( '"', t ) - 1 );    except      t := 'Not found';    end;    Result := t;  end;  // tIRC.JSONDefine  function tIRC.JSONSynonyms( s : string ) : string;    // returns synonyms as comma delimited string  var    i    : integer;    jDat : TJSONData;    t    : string;  begin    i := 0;    t := '';    jDat := GetJSON( s );    s := jDAT.AsJSON;    s:= copy( s, pos( '"synonyms"', s ) + 11, length( s ) );    while ( length( s ) > 0 ) and ( length( t ) < 200 ) do begin      s := copy( s, pos( '"id"', s ) + 8, length( s ) );      i := pos( '"', s ) - 1;      if length( t ) > 0        then t := t + ', ' + copy( s, 1, i )        else t := copy( s, 1, i );      s := copy( s, pos( '"', s ), length( s ) );    end;  // while    Result := t;  end;  // tIRC.JSONSynonyms            function tIRC.JSONWiki( s: string ) : string;      // returns content of field expr in JSON string s    var      t    : string;      u    : string;      v    : string;    begin      v := '';      t := copy( s, pos( '"extract":', s ) + 11, length( s ) );      if pos( '"missing"', t ) = 0 then begin        repeat          if pos( '.', t ) > 0             then u := copy( t, 1, pos( '.', t ) )            else u := copy( t, 1, pos( '"}}}', t ) - 1 );          if length( v ) + length( u ) <= 400            then v := v + u            else t := '';          if length( t ) > 0 then t := copy( t, length( u ) + 1, length( t ) );          if copy( t, 1, 7 ) = '"}}}' then t := '';        until t = '';      end else v := 'Not found';      v := StringReplace( v, '\n\n', '\n', [rfReplaceAll] );      v := StringReplace( v, '\n', ' -', [rfReplaceAll] );      if length( v ) = 0 then v := 'Not found';      result := v;    end;  // tIRC.JSONWiki        procedure tIRC.LoginID;      // Login    var      s : string;    begin      fCon.Line1( fUsername + ' ' + fVersion );      fCon.Send( 'Logging in',taNormal );  // Log in      s := 'NICK ' + fUserName;      MsgSend( s );      fCon.Send( fUserName + ': ' + s, taBold );      s := 'USER ' + fUserName + ' * * :ShaoB';      MsgSend( s );      fCon.Send( fUserName + ': ' + s, taBold );    end;  // tIRC.LoginID        procedure tIRC.MsgChat( s : string );      // send message to chat window    begin      EnterCriticalSection( fCritical );      s := 'PRIVMSG ' + fChannel + ' :' + s;      MsgSend( s );      LeaveCriticalSection( fCritical );    end;  // tIRC.MsgChat              procedure tIRC.MsgSend( s : string );      // Send message to channel    begin      fSock.SendString( s + CRLF );      if fSock.LastError <> 0  then fCon.Send( 'Send error: ' + fSock.LastErrorDesc, taBold );    end;  // tIRC.MsgSend      procedure tIRC.Nicks( s : string );      // Scan nicks on join and sends appropriate messages    var      t : string;      u : string;    begin      s := trim( s );      while length( s ) > 0 do begin        t := copy( s, 1, pos( ' ', s + ' '  ) - 1 );        s := copy( s, pos( ' ', s + ' ' ) + 1, length( s ) );        if length( t ) > 0 then begin          if pos( t[ 1 ], '@+!' ) > 0 then t := rightStr( t, length( t ) - 1 );          while fNote.Check( t ) do begin            u := fNote.Fetch( t );            if length( trim( u ) ) > 0 then begin              MsgChat( t + ' ' + u );              fCon.Send( fUserName + '> ' + t + ' ' + u, taBold );            end;          end;  // while        end;  // if length      end;  // while    end;  // tIRC.Nicks  function tIRC.Shao( nick, para, s : string ) : string;    // .Shao and .8Ball commands  begin    if length( para ) > 0 then begin      fBall8.LoadFromFile( 'shao.8ball' );      s := fBall8[ random( fBall8.Count ) ];      if random( 10 ) = 4 then s := s + ', ' + Nick;    end else s := 'Need something to work with';    Shao := s;  end;  // fIRC.Shao    function tIRC.SpaceX : string;    // Returns next planned launch of SpaceX  var    http : THTTPSend;    i    : integer;    jsn  : TJSONData;    res  : string;    s    : string;    str  : TStringList;  begin    res  := 'We have an anomoly!';    str  := TStringList.Create;    http := THTTPSend.Create;    http.Sock.SSL.SSLType := LT_TLSv1_2;    try      if http.HTTPMethod( 'GET', 'https://api.spacexdata.com/v3/launches/next' ) then begin        str.LoadFromStream( http.Document );        res := '';        for i := 0 to str.Count - 1 do res := res + str[ i ];        jsn := GetJSON( res );        res := 'Flight ' + jsn.FindPath( 'mission_number' ).AsString + ' ' + jsn.FindPath( 'mission_name' ).AsString;        res := res + ' from ' + jsn.FindPath( 'launch_site.site_name_long' ).AsString;        s   := ReplaceStr( jsn.FindPath( 'launch_date_utc' ).AsString, 'T', ' ' );        s   := leftStr( s, 16 );        res := res + ' at ' + s + ' UTC. ';        res := res + jsn.FindPath( 'description' ).AsString;      end else fCon.Send( 'Error: ' + http.Sock.SSL.LastErrorDesc, taNormal );    finally      str.Free;      http.Free;    end;    SpaceX := res;  end;  // tIRC.SpaceXend.  // sIRC //    http.Clear;//    http.KeepAlive  := FALSE;//    http.Protocol   := '1.1';//    http.TargetPort := '443';