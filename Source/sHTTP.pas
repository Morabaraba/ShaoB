{  sHTTP.pas  Copyright (c) 2019 Paul Davidson. All rights reserved.  Simple HTTP implementation for Shao  Knows about SSL}unit sHTTP;  {$MODE OBJFPC}  {$H+}interface  uses    Classes,    sSock,    SysUtils,    URIParser;  type        tHTTP = class( tSock )      private        fContentLength  : int64;        fHeaders        : TStringList;        fDataRead       : int64;        fHTTPVersion    : string;        fKeepConnection : boolean;        fResponseCode   : integer;        fResponseText   : string;        fURI            : TURI;      public        constructor Create;        destructor  Destroy; override;        property    ContentLength : int64 read fContentLength;        property    DataRead : int64 read fDataRead;        function    Get( uri : string ) : string;        property    HTTPVersion : string read fHTTPVersion write fHTTPVersion;        procedure   HeadersAdd( hd, vl : string );        procedure   HeadersDelete( hd : string );        function    HeadersGet( hd : string ) : string;    end;  // tHTTP  function URLEncode( s : string ) : string;implementation  const    CRLF = #13 + #10;  function URLEncode( s : string ) : string;    //  Make sure URL has safe chars  const    SafeChars = ['A'..'Z', '0'..'9', 'a'..'z', '*', '@', '.', '_', '-'];  var    i : integer;    t : string;  begin    t := '';    for i := 1 to Length( s ) do begin      if s[ i ] in SafeChars         then  t := t + s [ i ]        else if s[ i ]= ' '               then t := t + '+'              else t := t + '%' + intToHex( ord( s [ i ] ), 2 );    end;    URLEncode := t;  end;  // URLEncode    constructor tHTTP.Create;  begin    inherited Create;    fHTTPVersion    := '1.1';    fKeepConnection := FALSE;    Port            := 0;    fHeaders.Create;    fHeaders.Sorted := TRUE;    HeadersAdd( 'Accept', 'text/plain; q=0.5, text/html, test/JSON' );  end;  // tHTTP.Create;  destructor tHTTP.Destroy;  begin    fHeaders.Free;    inherited Destroy;  end;  // tHTP.Destroy  function tHTTP.Get( uri : string ) : string;    //  Get web page  var    i : integer;    s : string;  begin    s    := '';    fURI := ParseURI( uri );    if fURI.Port <> 0 then Port := fURI.Port;    if Port = 0      then if pos( 'HTTPS://', uppercase( uri ) ) > 0             then Port := 443             else Port := 80;    if Connect( fURI.Protocol + '//:' + fURI.Host, Port ) then begin           // Connect to host      if Send( 'GET ' + fURI.Host + ' ' + fHTTPVersion + CRLF ) then begin     // First line of HTTP        i := 0;        while ( i < fHeaders.Count ) and ( Error = 0 ) do begin                // Send request headers          Send( fHeaders[ i ] + CRLF );          inc( i );        end;        if Error = 0 then begin          Send( CRLF );                                                         // Send end of request                  end;      end;    end;  // if Connect    Get := s;  end;  // tHTTP.Get    procedure tHTTP.HeadersAdd( hd, vl : string );    // Add header, replacing existing one as required  var    i : integer;  begin    i := fHeaders.IndexOfName( hd );    if i > -1 then fHeaders.Delete( i );    fHeaders.Add( hd + '=' +vl );  end;  // tHTTP.HeadersAdd  procedure tHTTP.HeadersDelete( hd : string );    //  Delete header, if it exists  var    i : integer;  begin    i := fHeaders.IndexOfName( hd );    if i > -1 then fHeaders.Delete( i );  end;  // tHTTP.HeadersDelete  function tHTTP.HeadersGet( hd : string ) : string;    // Return header, if it exists  begin    HeadersGet := fHeaders.Values[ hd ]  end;  // tHTTP.HeadersGetend.  // sHTTP 